#include "downloader.h"
#include <curl/curl.h>
#include <iostream>
#include <thread>
#include <mutex>
#include <queue>

std::mutex queue_mutex;
std::queue<std::string> download_queue;

size_t write_data(void* ptr, size_t size, size_t nmemb, FILE* stream) {
    return fwrite(ptr, size, nmemb, stream);
}

void Downloader::download_file(const std::string& url) {
    CURL* curl;
    FILE* fp;
    CURLcode res;

    // Формирование имени файла из URL
    std::string filename = /* логика для получения имени файла */;
    
    log("Starting download: " + url);
    
    curl = curl_easy_init();
    if (curl) {
        fp = fopen(filename.c_str(), "wb");
        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);
        curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);

        res = curl_easy_perform(curl);
        if (res != CURLE_OK) {
            log("Error downloading " + url + ": " + curl_easy_strerror(res));
        } else {
            log("Finished downloading: " + url);
        }
        
        fclose(fp);
        curl_easy_cleanup(curl);
    }
}

Downloader::Downloader(const std::string& output_dir, int max_concurrent_downloads)
    : output_directory(output_dir), max_concurrent_downloads(max_concurrent_downloads) {}

void Downloader::download_files(const std::vector<std::string>& urls) {
    // Логика для параллельной загрузки файлов с учетом max_concurrent_downloads
}

